<!doctype html>
<html lang="en">
<head>
    <title>Bookclub session</title>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <style>
        body {
            background-image: url("fhp2.jpeg");
            background-color: #cccccc;
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
        }
        .mirrored {
            transform: scaleX(-1) ;
        }
        .footer {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            color: white;
            text-align: center;
        }
        html, body { height: 100%; width: 100%; margin: 0; }
        .all { height: 100%; width: 100%;}
    </style>

</head>
<body>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" crossorigin="anonymous"></script>
<a href="guest.html"><h1 id="title" class="text-center">Bookclub session</h1></a>

<div class="card container-fluid all" style="background: transparent;">
    <div id="remotes" class="card-header" >
        <video id="them" style="width:100%;height:fit-content;" autoplay playsinline ></video>
    </div>


    <div class="card-body">

        <div id="chosenAction" class="row justify-content-around">
            <button id="mute" type="button" class="col-4 btn btn-primary btn-lg"><i id="muteIcon" class="fa fa-microphone fa-2x" aria-hidden="true"></i></button>
            <button id="stopCall" type="button" class="col-4 btn btn-primary btn-lg"><i id="stopIcon" class="fa fa-stop fa-2x" aria-hidden="true"></i></button>
        </div>
        <div class="card-img-bottom row">
            <div class="col"><img style="width:inherit;" src="front.PNG" ></img> </div>
            <div class="col"><img style="width:inherit;" src="back.jpg"></img></div>
        </div>
    </div>
    <div class="card-footer">
        <h2><span class="badge badge-primary" id="role"></span><span class="badge badge-primary" id="status"></span></h2>
        <!--div style="width: 80px; height: 80px;" id="me">me</div-->
        <br/>
        <span>See our <a href="https://github.com/pipe/bookclub">Github</a> for source code</span>
        <span>See also <a href="https://pi.pe/privacy_policy/index.html">Privacy</a>
       and <a href="https://pi.pe/impressum/index.html">Impressum</a></span>
    </div>

</div>

<div id="share" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Send this url to the members. </h5>
            </div>
            <div class="modal-body" id="shareQR">
                <p>Share this URL to start a session</p>
                <p>You can use the share icon at the top of the screen</p>
                <p>Then email/sms it to each of the book club members</p>
                <p>Then press 'done'</p>
            </div>
            <div class="modal-footer">
                <button id="shareDone" type="button" class="btn btn-secondary" data-dismiss="modal" >Done</button>
            </div>
        </div>
    </div>
</div>

<div id="accept" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Accept a book club session</h5>
            </div>
            <div class="modal-body">
                <p>Click 'accept' to start the call.</p>
                <p>You also need to permit access to your microphone</p>
            </div>
            <div class="modal-footer">
                <button id="callAccept" type="button" class="btn btn-secondary" data-dismiss="modal" >Accept</button>
            </div>
        </div>
    </div>
</div>
<div id="nowebrtc" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Sorry</h5>
            </div>
            <div class="modal-body">
                <p>Unfortunately the browser you are using does not support WebRTC.</p>
                <p>Please retry using Safari, Chrome, FireFox, Edge - or pretty much any modern browser</p>
            </div>
            <div class="modal-footer">
                <button id="sadder" type="button" class="btn btn-secondary" data-dismiss="modal" >Accept</button>
            </div>
        </div>
    </div>
</div>
<div id="nomediaapi" class="modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Sorry</h5>
            </div>
            <div class="modal-body">
                <p>Unfortunately the browser you are using does not support the full webAudio API.</p>
                <p>Please try hosting the call with Chrome.</p>
                <p>The members can use any modern browser</p>
            </div>
            <div class="modal-footer">
                <button id="sad" type="button" class="btn btn-secondary" data-dismiss="modal" >Accept</button>
            </div>
        </div>
    </div>
</div>


<script type="module">



var socket; // used to set up connection with our peers.
var mid;
var cid;

var mute = false;
var peerConnectionOfferAnswerCriteria =  {offerToReceiveAudio: true, offerToReceiveVideo: true };
var properties = {};
var cropVideo = null;
const mungeing = false;
var sessions = {};
var localStream;


function Session() {
    this.pc = null;
    this.lcandyStash = [];
}
Session.prototype.answerDeal = function(data){
    this.pc.setRemoteDescription(data)
        .then( _ => {
            //$("#action").text("hangup");
        })
        .catch(e => console.log("set Remote answer error", e) );
};
Session.prototype.candidateDeal = function(data){
    var jc = {
        sdpMLineIndex: 0,
        candidate: data.sdp
    };
    console.log("adding candidate ", jc);
    var nc = new RTCIceCandidate(jc);
    this.pc.addIceCandidate(nc)
        .then( _ => console.log("added remote candidate"))
        .catch((e) => console.log("couldn't add candidate ", e));
};
Session.prototype.stopSession = function() {
    console.log("removing " + this.fid);
    delete sessions[this.fid];

    var that = this;

    if (this.checker != null) {
        window.clearTimeout(this.checker);
        this.checker = null;
    }

    if(this.pc != null){
        var mpc = this.pc;
        window.setTimeout(function () {

            stopCall(); // that is if we killed the (only) pc then byebye

        },5000);
        this.pc = null;
    }
};
Session.prototype.setupRTC = function(){
    console.log("setting up webRTC for "+this.fid);
    this.pc = new RTCPeerConnection(properties.configuration, null);
    this.pc.onicecandidate = (e) => {
            console.log("local ice candidate", e.candidate);
            if (e.candidate != null) {
                if (candyProt(e.candidate.candidate).toUpperCase()!="TCP") {
                    if (this.pc.signalingState == 'stable') {
                        sendMessage(this.fid, mid, "candidate", e.candidate.candidate);
                    } else {
                        console.log("stashing ice candidate");
                        this.lcandyStash.push(e.candidate);
                    }
                } else {
                    console.log("skip TCP candidates");
                }
            }
        };
        this.pc.oniceconnectionstatechange = (e) => {
            console.log("ice state is changed", this.pc.iceConnectionState);
            if (this.pc.iceConnectionState === "connected"){
                console.log(this.pc.getTransceivers());
                var sendtr = this.pc.getTransceivers().find( (tr) => tr &&  tr.sender && tr.sender.track && tr.sender.track.kind==="audio");
                if (sendtr) {
                    tweakOpus(sendtr.sender);
                }
            }
            /*
             "new"	The ICE agent is gathering addresses or is waiting to be given remote candidates through calls to RTCPeerConnection.addIceCandidate() (or both).
             "checking"	The ICE agent has been given one or more remote candidates and is checking pairs of local and remote candidates against one another to try to find a compatible match, but has not yet found a pair which will allow the peer connection to be made. It's possible that gathering of candidates is also still underway.
             "connected"	A usable pairing of local and remote candidates has been found for all components of the connection, and the connection has been established. It's possible that gathering is still underway, and it's also possible that the ICE agent is still checking candidates against one another looking for a better connection to use.
             "completed"	The ICE agent has finished gathering candidates, has checked all pairs against one another, and has found a connection for all components.
             "failed"	The ICE candidate has checked all candidates pairs against one another and has failed to find compatible matches for all components of the connection. It is, however, possible that the ICE agent did find compatible connections for some components.
             "disconnected"	Checks to ensure that components are still connected failed for at least one component of the RTCPeerConnection. This is a less stringent test than "failed" and may trigger intermittently and resolve just as spontaneously on less reliable networks, or during temporary disconnections. When the problem resolves, the connection may return to the "connected" state.
             "closed"
             */
            if (this.pc.iceConnectionState === "failed"){
                console.log("ice failed");
                this.stopSession();
            }
            if (this.pc.iceConnectionState === "closed"){
                console.log("ice closed");
                this.stopSession();
            }
            if (this.pc.iceConnectionState === "disconnected"){
                console.log("ice disconnected");
                setTimeout(() => {
                    if (this.pc.iceConnectionState != "connected"){
                        this.stopSession();
                    }
                },5000);
            }
        };

            this.pc.ontrack = (event) => {
                var stream = event.streams[0];
                console.log("got remote track ", event.track.kind);
                this.addStream(stream,event.track.kind);
            };

        // use this to determine the state of the 'hangup' button and send any candidates we found quickly
        this.pc.onsignalingstatechange = (evt) => {
            if (this.pc != null) {
                console.log("signalling state is ", this.pc.signalingState);
                if (this.pc.signalingState == 'stable') {
                    var can;
                    while (can = this.lcandyStash.pop()) {
                        console.log("popping candidate off stash");
                        sendMessage(this.fid, mid, "candidate", can.candidate);
                    }
                    var act = $("#stopCall");
                    act.click(_ => stopCall());
                    window.onbeforeunload = function () {
                        return this.pc!=null ? "If you leave this page you will end the connection." : null;
                    }
                }
            }
        };
};
Session.prototype.addStream = function(stream,kind) {
    if (!kind) {
        kind = "audio/video";
    }
    console.log("got new stream" + stream + " kind =" + kind);
    if (kind.indexOf("audio") != -1) {
        var that = this;
        $("#chosenAction").show();
    }
    var them = document.getElementById("them");

    console.log("added remote " + kind + " stream to videotag");
    them.srcObject = stream;
    $("#them").show();

};


Session.prototype.sendNewTrack = function(videoTrack){
    sessions.forEach((id,session) => {
        if (id !== this.fid) {
            let sender = session.pc.getSenders().find(function(s) {
                return ((!s.track) || ( s.track.kind === "video"));
            });
            if (sender) {
                sender.replaceTrack(videoTrack);
            } else {
                session.pc.addTrack(videoTrack);
            }
        } else {
            console.log("skip self " + id);
        }
    });
}




function rgb
(r, g,
 b){
    r = Math.floor(r);
    g = Math.floor(g);
    b = Math.floor(b);
    return ["rgb(",r,",",g,",",b,")"].join("");
}

    // message stuff - used to create direct connection to peer over WEBRTC

    function tweakSDP(sdp){
        var lines = sdp.split("\r\n");
        for (var i=0;i<lines.length;i++){
            var line = lines[i];
            if (line.startsWith("a=fmtp:111")){
                lines[i]= "a=fmtp:111 minptime=20; stereo=1; ptime=60; useinbandfec=1; maxaveragebitrate=32000";
            }
        }
        return (lines.join("\r\n"));
    }


function messageDeal(event){
    //console.log("message is ", event.data);
    var data = JSON.parse(event.data);
    console.log("message data is ", data);
    if (data.to != mid){
        alert("message mixup");
    }
    var session = sessions[data.from];
    switch (data.type) {
        case "offer":
            console.log("huh? Guests send offers");
            break;
        case "answer":
            if (session){
                session.answerDeal(data);
            }
            break;
        case "candidate":
            if (session) {
                session.candidateDeal(data);
            } else {
                console.log("should stash candidate for "+data.from);
            }
            break;
    }
}

function candyProt(candy){
    var ret = "none";
    var bits = candy.split(" ");
    if (bits.length >= 3){
        ret = bits[2];
    }
    return ret;
}
    function sendMessage(to,from,type,data){
        var messageJ = {
            to:to,
            from:from,
            type:type,
            sdp:data
        };

        var message = JSON.stringify(messageJ);
        console.log("sending ", messageJ);
        socket.send(message);
    }

    // button actions
    // this is singular -
    function startCall(fid){

        var that = sessions[cid];
        var pc = that.pc;

        that.statusChannel = pc.createDataChannel("status-"+Date.now());
        that.statusChannel.onopen = () => {
            console.log("guest's status channel opened - sending ping");
            that.statusChannel.send(JSON.stringify({act:"ping",date:Date.now()}));
        };
        that.statusChannel.onclose = (e) => {
            console.log("guest's status channel closed "+e);
        };
        that.statusChannel.onerror = (e) => {
            console.log("guest's status channel errored "+e);
        };
        console.log("created status datachannel");
        that.statusChannel.onmessage = (evt) => {
            statusDeal(evt);
        };
        pc.createOffer(peerConnectionOfferAnswerCriteria)
            .then(desc => {
                console.log("offer created",);
                //desc.sdp = tweakSDP(desc.sdp);
                pc.setLocalDescription(desc).then( d => {
                    sendMessage(fid, mid, desc.type, desc.sdp);
                    $("#status").text("Making call to host");
                }).catch (
                    e => {
                        console.log("Set Local failed");
                        // android cant do h264.
                        /*var t = pc.getLocalStreams()[0].getVideoTracks()[0];
                        clearCodecOrder(pc,t);
                        startCall(fid);
                        */
                    }
                );
            })
            .catch(e => console.log("offer not created due to ", e) );
    }


    function stopCall(){
        $("#status").text("Call ended.");
        document.location = "thanks.html";
    }

    function statusDeal(evt){
        console.log("got message "+evt.data);
        var mo = JSON.parse(evt.data);
        if (mo.act){
            if (mo.act =="add"){
                if (!sessions[mo.fid]) {
                    var sess = new Session(mo.fid, mo.pan);
                    console.log("adding user " + mo.fid);
                    sessions[mo.fid] = sess;
                }
            }
            if (mo.act =="del"){
                console.log("delete user "+mo.fid);
                var sess = sessions[mo.fid]
                if (sess){
                    sess.stopSession();
                }
            }
        } else {
            console.log("missing action");
        }
        $("#status").text("Call connected to "+ Object.keys(sessions).length + " member(s).");

    }

    // mute management
    function setMute(m){
        var mi = $("#muteIcon");
        mute = m;
        if (m){
            mi.removeClass("fa-microphone");
            mi.addClass("fa-microphone-slash");
        } else {
            mi.removeClass("fa-microphone-slash");
            mi.addClass("fa-microphone");
        }
        var audioTracks = localStream.getAudioTracks();
        if (audioTracks[0]) {
            audioTracks[0].enabled = !m;
        }
    }

async function captureRegion() {
    // set mcu  somehow.
    mcu = await navigator.mediaDevices.getDisplayMedia({
        audio: false,
        video: true,
        preferCurrentTab: true
    });
    var mcuT = mcu.getVideoTracks()[0];
    if ((cropVideo) && (mcuT.cropTo)) {
        await mcuT.cropTo(cropVideo);
    } else {
        console.log("No cropTarget or cropTo")
    }
}


    // plumb the local audio together.
function setupAudio() {
    var idealConstraints = {audio: true, video: {
            width: {  ideal: 240 },
            height: { ideal: 320 },
            frameRate: {ideal: 15},
        }};

    var promise = new Promise(function (resolve, reject) {
        navigator.mediaDevices.getUserMedia(idealConstraints)
            .then((stream) => {
                localStream = stream;
                var pc = sessions[cid].pc; // implicit detection of us being a guest
                stream.getTracks().forEach(track => {
                    pc.addTrack(track, stream);
                    console.log("added local track ", track.id, track.kind);
                    /*if (track.kind === "video") {
                        setCodecOrder(pc, track);
                    }*/
                });
                resolve(false);
            })
            .catch((e) => {
                console.log('getUserMedia() error:' + e);
                reject(e);
            });
    });
    return promise;
}

    function setupRTC() {
        var session = new Session(cid);
        session.setupRTC();
        sessions[cid] = session;
    }

    var playing = false;

    function toggleplay(){
        var audio = document.getElementById('them');
        if (!playing) {
            audio.play();
        } else {
            audio.pause();
        }
        playing = ! playing;
    }
    function shared() {
        setupRTC();
        setupAudio().then(_ => {
            console.log("ready for offer");
            $("#status").text("Waiting for guests.");
        });
    }
    function accepted() {
        setupRTC();
        setupAudio().then(_ => {
            console.log("ready for offer");
            $("#status").text("Mic available");
            startCall(cid)
        });
    }



    function loadProps() {
        var that = {configUrl: "pipeconfig.json"};
        var promise = new Promise(function (resolve, reject) {
            var xobj = new XMLHttpRequest();
            xobj.overrideMimeType("application/json");
            xobj.open('GET', that.configUrl, true);
            xobj.onreadystatechange = function () {
                if (xobj.readyState == 4 && xobj.status == "200") {
                    var pipeconfig = JSON.parse(xobj.responseText);
                    console.log("Config is " + xobj.responseText);
                    if (pipeconfig.ice) {
                        that.configuration = pipeconfig.ice;
                        console.log("Set ICE params " + JSON.stringify(that.configuration));
                    }
                    if (pipeconfig.wsurl) {
                        that.wsurl = pipeconfig.wsurl;
                        console.log("Set wsurl " + JSON.stringify(that.wsurl));
                    }
                    resolve(that);
                }
            };
            xobj.send(null);
        });
        return promise;
    }



async function setRole() {
    cid = $.getUrlVar("clubId");
    mid = localStorage['clubId'];
    if (!mid) {
        var array = new Uint32Array(8);
        window.crypto.getRandomValues(array);
        var hexCodes = [];
        for (var i = 0; i < array.length; i ++ ){
            // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
            var value = array[i];
            // toString(16) will give the hex representation of the number without padding
            var stringValue = value.toString(16);
            // We use concatenation and slice for padding
            var padding = '00000000';
            var paddedValue = (padding + stringValue).slice(-padding.length)
            hexCodes.push(paddedValue);
        }
        mid = hexCodes.join("").toLowerCase();
        console.log("mid =", mid);
        localStorage['clubId'] = mid;
    }
    properties = await loadProps();
    socket = new WebSocket( properties.wsurl + mid);
    socket.onmessage = messageDeal;
    socket.onopen = (_) => {
        var url = document.location.href;
        console.log("href = "+url);
        $("#role").text("Guest");
        $("#status").text("Waiting for connection");
        $("#accept").modal('show');
    };
    socket.onerror = (e) => {
        console.log("can't open websocket", e);
        $("#status").text("Internet problems ?");

    };
    socket.onclose = (e) => {
        console.log(" websocket closed", e);
        $("#status").text("Server problems ?");
    };

}

function codecPriority(codecMime){
    var ret = 2;
    if (codecMime.includes("h264") || codecMime.includes("H264")){
        ret = 1;
    } else if (codecMime.includes("h265") || codecMime.includes("H265")){
        ret =0;
    }
    return ret;
}

function tweakOpus(send) {
    if(!mungeing) {
        const paras = send.getParameters();
        console.log("initial audio encoder params");
        console.log(paras);
        if ((paras) && (paras.encodings)) {
            paras.encodings[0].maxBitrate = 64000;
            //paras.encodings[0].ptime = 60;
            send.setParameters(paras);
            console.log(paras);
        }
    }
}
function setCodecOrder(pc,track){
    if (!mungeing) {
        if (RTCRtpSender.getCapabilities) {
            const {codecs} = RTCRtpSender.getCapabilities('video');
            console.log("default video codecs ");
            codecs.forEach((v) => {
                console.log(v.mimeType);
            })
            codecs.sort((a, b) => codecPriority(a.mimeType) - codecPriority(b.mimeType));
            console.log("ordered video codecs ")
            codecs.forEach((v) => {
                console.log(v.mimeType);
            })
            const transceiver = pc.getTransceivers().find(t => t.sender && t.sender.track === track);
            transceiver.setCodecPreferences(codecs);
            console.log('Flipped  video codec');
        } else {
            console.log('Default  video codecs');
        }
    }
}
function clearCodecOrder(pc,track){
    if (!mungeing) {
        if (RTCRtpSender.getCapabilities) {
            const {codecs} = RTCRtpSender.getCapabilities('video');
            console.log("default video codecs ");
            codecs.forEach((v) => {
                console.log(v.mimeType);
            })
            const transceiver = pc.getTransceivers().find(t => t.sender && t.sender.track === track);
            transceiver.setCodecPreferences(codecs);
            console.log('Flipped  video codec');
        } else {
            console.log('Default  video codecs');
        }
    }
}

    function getSize(stream){
        var settings = null;
        var vtracks = stream.getVideoTracks();
        if ((vtracks) && (vtracks.length > 0)) {
            var settings = vtracks[0].getSettings();
            console.log("video stream is " + settings.width + " x " + settings.height);
        }
        return settings;
    }


    // some housekeeping

    $.extend({
        getUrlVars: function(){
            var vars = [], hash;
            var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
            for(var i = 0; i < hashes.length; i++)
            {
                hash = hashes[i].split('=');
                vars.push(hash[0]);
                vars[hash[0]] = hash[1];
            }
            return vars;
        },
        getUrlVar: function(name){
            return $.getUrlVars()[name];
        }
    });

    $( document ).ready( _ => {
        $("#chosenAction").hide();
        $("#packetLoss").hide();
        $("#statsZone").hide();
        $("#them").hide();

        document.getElementById("callAccept").onclick = accepted;
        document.getElementById("shareDone").onclick = shared;


        if (('RTCPeerConnection' in window ) && ('createDataChannel' in RTCPeerConnection.prototype)){
            $("#mute").click(_ => setMute(!mute));
            setRole();
        } else {
            $('#nowebrtc').modal('show');
        }
    });
</script>
</body>
</html>
